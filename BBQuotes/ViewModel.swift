//
//  ViewModel.swift
//  BBQuotes
//
//  Created by Vladyslav Tarabunin on 27/05/2025.
//

import Foundation
//האובסרבאבל הוא מאפיין אטריביוט שמסמן שמחלקה או מבנה סטרוקט או קלאס תומכים בהתעדכנות אוטומטית של ממשק המשתמש כשנתונים משתנים.
//זה חלק ממערכת סוויפט דאטה או סוויפט יו איי תלוי בהקשר ומאפשר להשתמש בדאטה ביינדינג  כלומר כשהנתון משתנה הממשק מתעדכן לבד.
//מיין אקטור הוא מאפיין אטריביוט שאומר לקומפיילר שהקוד שמסומן בו חייב לרוץ על המיין טרד כלומר על האשכול הראשי של האפליקציה.
//בממשקי אפל, ממשק המשתמש חייב להתעדכן רק מתוך המיין טרד אם תנסה לעדכן את הממשק מתוך אשכול אחר בקגראונד טרד זה עלול לגרום לקריסות או באגים.
@Observable
@MainActor
class ViewModel {
    enum FetchStatus {
        case notStarted
        case fetching
        case successQuote
        case successEpisode
        case failed(error: Error)
    }
    //פריבט סט אומר שהוא חלקית קשור רק לקובץ הזה זאת אומרת שבכל הקבצים אפשר לראות ולהשתמש בו אבל לא לשנות אותו
    //המשתנה סטטוס שומר סטטוס של תהליך (למשל הורדת נתונים), אפשר לקרוא אותו מבחוץ  אבל רק לשנות אותו מתוך המחלקה עצמה. זה עוזר לשמור על שליטה ובטיחות בקוד.
    //קיצור הגדרנו סטטוס התחלתי
    private(set) var status: FetchStatus = .notStarted
    //יצרנו משתנה פטשר שמייבא נתונים מרובץ פטש סרוויס
    private let fetcher = FetchService()
    //הגדרה של שני משתנים  אחד שמכיל ציטוט, ואחד שמכיל דמות זה חלק ממבנה שמקשר בין דמות לציטוט שלה.
    //הוספנו משתנה של פרקים שיביא גם פרקים
    var quote: Quote
    var character: Char
    var episode: Episode
    
    //פונקציית אינט היא פונקצייה שפועלת אוטומטית ברגע שהקלאס מקבל איתחול
    init() {
        //כאן נוצר מופע חדש של גייסוןדיקוד, מחלקה שממירה נתוני גייסון לאובייקטים של סוויפט.
        let decoder = JSONDecoder()
        //הגדרה זו אומרת לדקודר שכשמזהים מפתחות קייס בקובץ הגייסון הם יומרו מסנייק קייס לקאמל קייס.
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        //כאן נטען קובץ גייסון בשם סאמפלקווט גייסון מתוך המשאבים באנדל של האפליקציה והופכים אותו לאובייקט מסוג דאטה.
        //טריי עם סימן קריאה אומר שהתוכנית תקרוס אם תהיה שגיאה  לדוגמה אם הקובץ לא קיים.
        let quoteData = try! Data(contentsOf: Bundle.main.url(forResource: "samplequote", withExtension: "json")!)
        //כאן מנסים לפענח לעשות דיקוד את הנתונים שנטענו לקובץ קווטדאטה ולהמיר אותם לאובייקט מסוג קווט.
        quote = try! decoder.decode(Quote.self, from: quoteData)
        //כאן שוב נטען קובץ סמפלקרקטר בדיוק סאמפלדאטה הפעם על קרקטר.
        let characterData = try! Data(contentsOf: Bundle.main.url(forResource: "samplecharacter", withExtension: "json")!)
        //כאן מפענחים את הנתונים שוב, הפעם לאובייקט מסוג צאר
        character = try! decoder.decode(Char.self, from: characterData)
        //כאן שוב נטען קובץ סמפלאפיסוד בדיוק סאמפלדאטה הפעם על פרקים.
        let episodeData = try! Data(contentsOf: Bundle.main.url(forResource: "sampleepisode", withExtension: "json")!)
        //כאן מפענחים את הנתונים שוב, הפעם לאובייקט מסוג פרק
        episode = try! decoder.decode(Episode.self, from: episodeData)
    }
    //זוהי פונקציה אסינכרונית שמקבלת מחרוזת שואו שם הסידרה ומבצעת פעולות הקשורות אליה.
    //המילה אסינק אומרת שהפונקציה רצה בצורה אסינכרונית  כלומר היא יכולה להשתמש באוויט בלי לחסום את ממשק המשתמש בזמן ההמתנה לתשובה מהשרת
    func getQuoteData(for show: String) async{
        //מעדכנים את הסטטוס של האובייקט כנראה ויומודל למצב ״בתהליך טעינה״. יכול לשמש, לדוגמה, כדי להציג ספינר במסך בזמן שהנתונים נטענים.
        status = .fetching
        //פותחים בלוק של דו קטש כדי לטפל בשגיאות שיכולות לקרות במהלך הקריאות האסינכרוניות.
        do {
            //מחכים באופן אסינכרוני לקבלת קווט  מהסדרה הנתונה. אם יש שגיאה למשל  אין חיבור אינטרנט או שם סדרה לא תקף  זה יקפוץ לקטש
            quote = try await fetcher.fetchQuote(from: show)
            //כאן משתמשים במידע שקיבלו בציטוט — השם של הדמות — ומביאים את פרטי הדמות מהשרת.
            character = try await fetcher.fetchCharacter(quote.character)
            //בודקים אם הדמות הזו מתה, ומעדכנים את המידע של הדמות בהתאם.
            character.death = try await fetcher.fetchDeath(for: character.name)
            //אם הכל עבר בשלום – מעדכנים את הסטטוס להצלחה.
            status = .successQuote
            //אם אחת מהפעולות זרקה שגיאה – הקוד יגיע לפה.
        } catch{
            //מעדכנים את הסטטוס לכישלון ושומרים את השגיאה כדי שאפשר יהיה להציג אותה למשתמש או לטפל בה.
            status = .failed(error: error)
//טריי זה פקודה שמציין שיתכן הפעולה תכשל ותזרוק שגיאה וצריך לנסות אותה
//אוויט מציין שמדובר בפעולה אסינכרונית שיכולה לקחת זמן ולכן צריך לחכות לה
//טריי אוויט אומר נסה להמתין לפעולה שעלולה להכשל
        }
    }
    
    func getEpisode(for show: String) async{
        //מעדכנים את הסטטוס של האובייקט כנראה ויומודל למצב ״בתהליך טעינה״. יכול לשמש, לדוגמה, כדי להציג ספינר במסך בזמן שהנתונים נטענים.
        status = .fetching
        //פותחים בלוק של דו קטש כדי לטפל בשגיאות שיכולות לקרות במהלך הקריאות האסינכרוניות.
        do {
            //שורה זו בודקת אם התקבלה תוצאה תקינה מאייפיאיי או מפונקציה אסינכרונית שמחזירה פרק
            if let unwrappedEpisode = try await fetcher.fetchEpisode(from: show) {
                episode = unwrappedEpisode
            }
            
            status = .successEpisode
        } catch {
            status = .failed(error: error)
//טריי זה פקודה שמציין שיתכן הפעולה תכשל ותזרוק שגיאה וצריך לנסות אותה
//אוויט מציין שמדובר בפעולה אסינכרונית שיכולה לקחת זמן ולכן צריך לחכות לה
//טריי אוויט אומר נסה להמתין לפעולה שעלולה להכשל
        }
    }
}
